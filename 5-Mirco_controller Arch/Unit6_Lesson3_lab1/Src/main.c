/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#define RCC_base 0x40021000
#define RCC_CR *((volatile uint32_t * )(RCC_base + 0x00))
#define RCC_CFGR *((volatile uint32_t * )(RCC_base + 0x04))
#define RCC_APB2ENR *((volatile uint32_t * )(RCC_base + 0x18))


#define GPIOA_BASE 0x40010800
#define GPIOA_CRH *(volatile uint32_t *)(GPIOA_BASE + 0x04)
#define GPIOA_ODR *(volatile uint32_t *)(GPIOA_BASE + 0x0C)


void clk_init(void ){
	// select source of clk HSI
	//RCC_CFGR |= (0b111<<24) ;
	// enable clk for port A
	RCC_APB2ENR|=(1<<2) ;

}

void GPIO_init (void ){
	//Init GPIOA
	GPIOA_CRH &= 0xFF0FFFFF;
	GPIOA_CRH |= 0x00200000 ;
}

int main(void)
{
	clk_init() ;
	GPIO_init();
    /* Loop forever */
while (1)
{
	GPIOA_ODR |= 1<<13 ;
	for (int i = 0; i < 5000; i++); // arbitrary delay
	GPIOA_ODR &= ~(1<<13) ;
	for (int i = 0; i < 5000; i++); // arbitrary delay
}
return 0 ;

}

//#include <stdint.h>
//
//
//typedef volatile uint32_t vuint32_t ;
//
//
//#define RCC_BASE 			0x40021000
//#define	GPIOA_BASE			0x40010800
//#define RCC_APB2ENR			*(vuint32_t *)(RCC_BASE+0x18)
//#define GPIOA_CHR 			*(vuint32_t *)(GPIOA_BASE+0x04)
//#define GPIO_ODR			*(vuint32_t *)(GPIOA_BASE+0x0c)
//
//
//#define RCC_IOPAEN 			(1<<2)
//#define GPIOA_P13			(1ul<<13)
////bitfields
//
//typedef union {
//	vuint32_t all_R ;
//	struct
//	{
//		vuint32_t reserved :13 ;
//		vuint32_t p_13 :1 ;
//
//	}pin;
//}R_ODR_t ;
//
//
//
//int main(void)
//{
//	volatile R_ODR_t* R_ODR = (volatile R_ODR_t *)(GPIOA_BASE+0x0C);
//
//	RCC_APB2ENR|= RCC_IOPAEN ;
//	GPIOA_CHR &=0xff0fffff ;
//	GPIOA_CHR |=0x00200000 ;
//
//	while(1)
//	{
//
//		int i ;
//		//GPIO_ODR&=(~GPIOA_P13);
//		R_ODR->pin.p_13=0 ;
//		for (i=0 ;i<5000;i++) ;
//		//GPIO_ODR|=(GPIOA_P13);
//		R_ODR->pin.p_13= 1;
//		for (i=0 ;i<5000;i++) ;
//
//
//	}
//}
